description: Pipeline to preprocess FAIR data - Final fix to match RDF logic exactly

target: bsrc_d.int_{{ RUN_MONTH }}.fair_turnover

sources:
  - alias: UCR_ACTUAL
    columns:
      - COMPANY_ID
      - RATING_ID
      - RATING_STATUS
      - PARENT_COMPANY_ID
      - LB_RATING_ID
    source: int_{{ RUN_MONTH }}.pd_ucr_actual
  
  - alias: PD_ITERATIONS
    columns:
      - RATING_ID
      - RECOMMENDED
      - ITERATION_NUMBER
    # NO FILTER - Use all iterations like RDF does
    source: stg_{{ RUN_MONTH }}.dial_fair_pd_iterations
  
  - alias: MODEL_ESSENTIALS
    columns:
      - RATING_ID
      - CALCULATION_PERIOD_ID
      - MODEL_COMPONENT_ESSENTIAL_TYPE_CODE
      - MODEL_COMPONENT_ESSENTIAL_VALUE
      - MODEL_COMPONENT_ESSENTIAL_CATEGORY_VARIANT_ID
      - ITERATION_NUMBER
    filter: MODEL_COMPONENT_ESSENTIAL_TYPE_CODE IN ('CorrectedTotalAssets', 'TotalBalanceSheet', 'Assets', 'TotalAssets', 'TotalTurnoverTurnover', 'Turnover', 'Budget', 'Revenues', 'TotalRevenues', 'TotalOperatingIncome') AND MODEL_COMPONENT_ESSENTIAL_CATEGORY_VARIANT_ID = 'cons'
    source: stg_{{ RUN_MONTH }}.dial_fair_pd_model_component_essentials
  
  - alias: LBR_QUANTITATIVE
    columns:
      - LB_RATING_ID
      - DATA_TYPE
      - TOTAL_ASSETS
      - NET_INTEREST_YIELD
      - OTHER_OPERATING_INCOME
    filter: DATA_TYPE = 2
    source: stg_{{ RUN_MONTH }}.dial_fair_lbr_quantitative_input

transformations:
  # Step 1: Join iterations with model essentials (no recommended filter)
  - join:
      left_source: PD_ITERATIONS
      right_source: MODEL_ESSENTIALS
      condition:
        - PD_ITERATIONS.ITERATION_NUMBER = MODEL_ESSENTIALS.ITERATION_NUMBER
        - PD_ITERATIONS.RATING_ID = MODEL_ESSENTIALS.RATING_ID
      how: inner
  
  # Step 2: Pivot to get model component values as columns
  - pivot:
      alias: PIVOTED_MODEL
      source: PD_ITERATIONS
      group_cols:
        - PD_ITERATIONS.RATING_ID
        - PD_ITERATIONS.ITERATION_NUMBER
      pivot_col: MODEL_ESSENTIALS.MODEL_COMPONENT_ESSENTIAL_TYPE_CODE
      pivot_value_col: MODEL_ESSENTIALS.MODEL_COMPONENT_ESSENTIAL_VALUE
      column_mapping:
        CorrectedTotalAssets: first
        TotalBalanceSheet: first
        Assets: first
        TotalAssets: first
        TotalTurnoverTurnover: first
        Turnover: first
        Budget: first
        Revenues: first
        TotalRevenues: first
        TotalOperatingIncome: first
  
  # Step 3: Aggregate to get one record per RATING_ID (use first iteration)
  - aggregation:
      alias: MODEL_DATA_AGG
      source: PIVOTED_MODEL
      group:
        - PIVOTED_MODEL.RATING_ID
      column_mapping:
        CorrectedTotalAssets: first(PIVOTED_MODEL.CorrectedTotalAssets)
        TotalBalanceSheet: first(PIVOTED_MODEL.TotalBalanceSheet)
        Assets: first(PIVOTED_MODEL.Assets)
        TotalAssets: first(PIVOTED_MODEL.TotalAssets)
        TotalTurnoverTurnover: first(PIVOTED_MODEL.TotalTurnoverTurnover)
        Turnover: first(PIVOTED_MODEL.Turnover)
        Budget: first(PIVOTED_MODEL.Budget)
        Revenues: first(PIVOTED_MODEL.Revenues)
        TotalRevenues: first(PIVOTED_MODEL.TotalRevenues)
        TotalOperatingIncome: first(PIVOTED_MODEL.TotalOperatingIncome)
  
  # Step 4: LEFT JOIN with UCR to get all records
  - join:
      left_source: UCR_ACTUAL
      right_source: MODEL_DATA_AGG
      condition:
        - UCR_ACTUAL.RATING_ID = MODEL_DATA_AGG.RATING_ID
      how: left
  
  # Step 5: Create calculated columns
  - aggregation:
      alias: DIRECT
      source: UCR_ACTUAL
      group:
        - UCR_ACTUAL.RATING_ID
        - UCR_ACTUAL.COMPANY_ID  
        - UCR_ACTUAL.PARENT_COMPANY_ID
        - UCR_ACTUAL.LB_RATING_ID
      column_mapping:
        TotalAssets: first(COALESCE(MODEL_DATA_AGG.CorrectedTotalAssets, MODEL_DATA_AGG.TotalBalanceSheet, MODEL_DATA_AGG.Assets, MODEL_DATA_AGG.TotalAssets))
        Turnover: first(COALESCE(MODEL_DATA_AGG.TotalTurnoverTurnover, MODEL_DATA_AGG.Turnover, MODEL_DATA_AGG.Budget, MODEL_DATA_AGG.Revenues, MODEL_DATA_AGG.TotalRevenues, MODEL_DATA_AGG.TotalOperatingIncome))
  
  # Step 5: Join with LBR data
  - join:
      left_source: DIRECT
      right_source: LBR_QUANTITATIVE
      condition:
        - DIRECT.LB_RATING_ID = LBR_QUANTITATIVE.LB_RATING_ID
      how: left

expressions:
  RatingID: DIRECT.RATING_ID
  # Simple hierarchy: LBR if available, otherwise Direct (no parent)
  AnnualTurnover: COALESCE(
    CASE 
      WHEN LBR_QUANTITATIVE.NET_INTEREST_YIELD IS NOT NULL AND LBR_QUANTITATIVE.OTHER_OPERATING_INCOME IS NOT NULL 
      THEN CAST((LBR_QUANTITATIVE.NET_INTEREST_YIELD + LBR_QUANTITATIVE.OTHER_OPERATING_INCOME) * 1000000000 AS STRING) 
    END, 
    DIRECT.Turnover
    )
  AnnualTurnoverDirect: DIRECT.Turnover
  AnnualTurnoverLBR: CASE 
    WHEN LBR_QUANTITATIVE.NET_INTEREST_YIELD IS NOT NULL AND LBR_QUANTITATIVE.OTHER_OPERATING_INCOME IS NOT NULL 
    THEN CAST((LBR_QUANTITATIVE.NET_INTEREST_YIELD + LBR_QUANTITATIVE.OTHER_OPERATING_INCOME) * 1000000000 AS STRING) 
    END
  TotalAssets: COALESCE(
    CASE 
      WHEN LBR_QUANTITATIVE.TOTAL_ASSETS IS NOT NULL 
      THEN CAST(LBR_QUANTITATIVE.TOTAL_ASSETS * 1000000000 AS STRING) 
    END, 
    DIRECT.TotalAssets
    )
  TotalAssetsDirect: DIRECT.TotalAssets
  TotalAssetsLBR: CASE 
    WHEN LBR_QUANTITATIVE.TOTAL_ASSETS IS NOT NULL 
    THEN CAST(LBR_QUANTITATIVE.TOTAL_ASSETS * 1000000000 AS STRING) 
    END
  # Source tracking
  TurnoverSource: CASE
    WHEN LBR_QUANTITATIVE.NET_INTEREST_YIELD IS NOT NULL AND LBR_QUANTITATIVE.OTHER_OPERATING_INCOME IS NOT NULL THEN 'LBR'
    WHEN DIRECT.Turnover IS NOT NULL THEN 'Direct'
    ELSE 'None'
    END
  AssetsSource: CASE
    WHEN LBR_QUANTITATIVE.TOTAL_ASSETS IS NOT NULL THEN 'LBR'
    WHEN DIRECT.TotalAssets IS NOT NULL THEN 'Direct'
    ELSE 'None'
    END

drop_duplicates: true
